# Delivr Server OTA - Cursor Rules

## Reference Documentation
- Main Coding Standards: `../docs/CODING_STANDARDS.md`
- Clean Code Quick Reference: `../docs/CLEAN_CODE_QUICK_REFERENCE.md`

## Constants Organization

### Global vs Domain-Specific Constants

**CRITICAL RULE**: Always place constants in the appropriate scope based on their usage.

### 1. Global Constants (`api/script/utils/`)

Place constants in appropriately named files using `[category].constants.ts`:
- ✅ HTTP-related constants → `http.constants.ts`
- ✅ Validation constants → `validation.constants.ts`
- ✅ Application config constants → `app.constants.ts`

**DO NOT** use generic names like `constants.ts`

```typescript
// ❌ BAD: Generic file name or wrong separator
// api/script/utils/constants.ts
// api/script/utils/http-constants.ts (wrong separator)
export const HTTP_STATUS = { ... };
export const RESPONSE_STATUS = { ... };

// ✅ GOOD: Specific category with dot separator
// api/script/utils/http.constants.ts
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500
} as const;

export const RESPONSE_STATUS = {
  SUCCESS: true,
  FAILURE: false
} as const;
```

**Available Constants**: Always check if constants already exist before creating new ones:
- Node.js built-in: `http.STATUS_CODES` (code → text mapping)
- Express: Use `res.status(200)` directly
- Consider: `http-status-codes` npm package (3.6 kB gzipped) for comprehensive status codes

### 2. Domain-Specific Constants

Place in domain/feature directories when they are:
- ✅ Feature-specific error messages
- ✅ Feature-specific success messages  
- ✅ Domain business logic values
- ✅ Feature-specific configuration

**CRITICAL NAMING RULES**:
1. **Constant names MUST include domain/feature prefix** for clarity
2. **Message strings MUST include context** about the domain/feature
3. **Never use generic names** like `ERROR_MESSAGES` or `SUCCESS_MESSAGES`

```typescript
// ❌ BAD: Generic names and messages without context
// api/script/controllers/integrations/test-management/constants.ts
export const ERROR_MESSAGES = {
  CREATE_INTEGRATION_FAILED: 'Failed to create integration',  // What kind of integration?
  INTEGRATION_NOT_FOUND: 'Integration not found',  // What domain?
} as const;

export const SUCCESS_MESSAGES = {
  INTEGRATION_DELETED: 'Integration deleted successfully',  // No context
} as const;

// ✅ GOOD: Prefixed names and messages with context
// api/script/controllers/integrations/test-management/constants.ts
export const TEST_MANAGEMENT_ERROR_MESSAGES = {
  CREATE_INTEGRATION_FAILED: 'Failed to create test management integration',
  INTEGRATION_NOT_FOUND: 'Test management integration not found',
  LINK_INTEGRATION_FAILED: 'Failed to link test management integration to release config',
  // ... other test-management specific errors
} as const;

export const TEST_MANAGEMENT_SUCCESS_MESSAGES = {
  INTEGRATION_DELETED: 'Test management integration deleted successfully',
  // ... other test-management specific messages
} as const;
```

**Why This Matters**:
- Looking at `TEST_MANAGEMENT_ERROR_MESSAGES` immediately tells you the domain
- Error messages with context are clearer in logs and user interfaces
- Prevents confusion when multiple domains have similar operations
- Makes codebase more maintainable and self-documenting

### 3. Provider-Specific Constants

Place in provider directories when they are:
- ✅ Provider-specific API configurations
- ✅ Provider-specific HTTP status codes (extended set)
- ✅ Provider-specific timeouts and limits
- ✅ Provider-specific defaults

```typescript
// ✅ GOOD: Provider-specific constants
// api/script/services/integrations/test-management/providers/checkmate/checkmate.constants.ts
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,      // Extended for this provider
  FORBIDDEN: 403,         // Extended for this provider
  NOT_FOUND: 404,
  TIMEOUT: 408,           // Extended for this provider
  INTERNAL_SERVER_ERROR: 500,
  SERVICE_UNAVAILABLE: 503  // Extended for this provider
} as const;

export const TIMEOUTS = {
  VALIDATION: 10000,
  DEFAULT: 30000,
  LONG_RUNNING: 60000
} as const;
```

## Import Guidelines

### Module Aliases (Already Configured)
Use TypeScript path aliases for imports:
- `~types` → `./bin/script/types`
- `~models` → `./bin/script/models`
- `~services` → `./bin/script/services`
- `~controllers` → `./bin/script/controllers`
- `~routes` → `./bin/script/routes`
- `~utils` → `./bin/script/utils`
- `~middleware` → `./bin/script/middleware`
- `~storage` → `./bin/script/storage`

### Correct Import Patterns

```typescript
// ✅ GOOD: Import global constants from utils
import { HTTP_STATUS, RESPONSE_STATUS } from '~utils/constants';

// ✅ GOOD: Import domain constants from feature directory
import { ERROR_MESSAGES, SUCCESS_MESSAGES } from '../constants';

// ❌ BAD: Don't mix global and domain constants in the same file
// api/script/controllers/integrations/test-management/constants.ts
export const HTTP_STATUS = { ... };  // ❌ This is global, not domain-specific
export const ERROR_MESSAGES = { ... };  // ✅ This is domain-specific
```

## No Magic Values

### CRITICAL RULE: NO Hardcoded Values ANYWHERE

**This applies to ALL code - controllers, services, utilities, helpers, everywhere!**

### Always use constants, never hardcoded values:

```typescript
// ❌ BAD: Hardcoded status code in controller
res.status(400).json({ error: 'Bad request' });

// ✅ GOOD: Use constant in controller
import { HTTP_STATUS } from '~constants/http';
res.status(HTTP_STATUS.BAD_REQUEST).json({ error: 'Bad request' });

// ❌ BAD: Hardcoded status codes in utility function
export const getErrorStatusCode = (error: unknown): number => {
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    if (message.includes('not found')) return 404;  // ❌ Hardcoded!
    if (message.includes('unauthorized')) return 401;  // ❌ Hardcoded!
    if (message.includes('forbidden')) return 403;  // ❌ Hardcoded!
  }
  return 500;  // ❌ Hardcoded!
};

// ✅ GOOD: Use constants in utility function
import { HTTP_STATUS } from '~constants/http';

export const getErrorStatusCode = (error: unknown): number => {
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    if (message.includes('not found')) return HTTP_STATUS.NOT_FOUND;
    if (message.includes('unauthorized')) return HTTP_STATUS.UNAUTHORIZED;
    if (message.includes('forbidden')) return HTTP_STATUS.FORBIDDEN;
  }
  return HTTP_STATUS.INTERNAL_SERVER_ERROR;
};

// ❌ BAD: Magic string
throw new Error('Failed to create integration');

// ✅ GOOD: Use domain-prefixed constant with context
import { TEST_MANAGEMENT_ERROR_MESSAGES } from '../constants';
throw new Error(TEST_MANAGEMENT_ERROR_MESSAGES.CREATE_INTEGRATION_FAILED);
```

**Key Points:**
- Import `HTTP_STATUS` from `~constants/http` (NOT from local/provider constants)
- Never use numeric literals for HTTP status codes (400, 401, 404, 500, etc.)
- This rule applies to utility functions, not just controllers
- Even single-use status codes should use constants for consistency

## Quick Checklist Before Creating Constants

Before creating a new constant file or adding constants, ask:

1. **Is this generic/global?** → Use `~utils/constants`
2. **Is this feature/domain-specific?** → Create/use `domain/constants.ts`
3. **Is this provider/integration-specific?** → Create/use `provider/provider.constants.ts`
4. **Does this already exist?** → Search codebase first with grep/codebase_search
5. **Can I use a built-in?** → Check Node.js, Express, or npm packages first
6. **Does the name include the domain prefix?** → Use `DOMAIN_ERROR_MESSAGES`, not `ERROR_MESSAGES`
7. **Do messages include context?** → "Test management integration not found", not "Integration not found"

## TypeScript Best Practices

### NEVER Use `as` or `!` Operators (Strict Typing)

**CRITICAL RULE**: Never use type assertions (`as`) or non-null assertions (`!`) - always use proper type guards and validation.

```typescript
// ❌ BAD: Using 'as' operator
const projectId = parameters.projectId as number;
const config = baseConfig as CheckmateConfig;
const value = obj.prop as string | undefined;

// ❌ BAD: Using '!' non-null assertion
const user = getUser()!;
const id = user!.id;

// ✅ GOOD: Proper type guard with validation
private isCheckmateConfig = (config: ProjectTestManagementIntegrationConfig): config is CheckmateConfig => {
  const hasBaseUrl = 'baseUrl' in config && typeof config.baseUrl === 'string';
  const hasAuthToken = 'authToken' in config && typeof config.authToken === 'string';
  return hasBaseUrl && hasAuthToken;
};

private getCheckmateConfig = (config: ProjectTestManagementIntegrationConfig): CheckmateConfig => {
  const isValidConfig = this.isCheckmateConfig(config);
  
  if (!isValidConfig) {
    throw new Error(ERROR_MESSAGES.INVALID_CONFIG);
  }
  
  return config; // TypeScript knows it's CheckmateConfig now
};

// Usage
const checkmateConfig = this.getCheckmateConfig(config); // No 'as' needed!

// ✅ GOOD: Use already-typed properties
const projectId = parameters.projectId; // Already typed as number | undefined
const runName = parameters.runName || 'Test Run'; // Already typed as string | undefined
```

**Why this matters:**
- Type assertions bypass TypeScript's type checking
- `as` can hide bugs by forcing incorrect types
- `!` can cause runtime errors if value is actually null/undefined
- Proper type guards provide runtime safety + compile-time safety

### ALWAYS Use Null Coalescing (`??`) Instead of Logical OR (`||`)

**CRITICAL RULE**: Use `??` (nullish coalescing) for default values, not `||` (logical OR).

```typescript
// ❌ BAD: Using || for default values (fails with falsy values)
const threshold = config.passThreshold || 80;  // ❌ Fails if threshold is 0!
const count = result.total || 0;               // ❌ Fails if total is 0!
const name = user.name || 'Anonymous';         // ❌ Fails if name is ''!
const enabled = settings.enabled || true;      // ❌ Fails if enabled is false!

// ✅ GOOD: Using ?? for null/undefined only
const threshold = config.passThreshold ?? 80;  // ✅ Uses 80 only if null/undefined
const count = result.total ?? 0;               // ✅ Uses 0 only if null/undefined
const name = user.name ?? 'Anonymous';         // ✅ Uses 'Anonymous' only if null/undefined
const enabled = settings.enabled ?? true;      // ✅ Uses true only if null/undefined
```

**Why this matters:**
- `||` treats ALL falsy values as "use default": `0`, `''`, `false`, `null`, `undefined`, `NaN`
- `??` ONLY treats `null` and `undefined` as "use default"
- Using `||` can lead to subtle bugs where valid falsy values are replaced with defaults
- `??` makes intent clear: "Use this value unless it's null or undefined"

**Common mistake example:**
```typescript
// ❌ BAD: User sets threshold to 0 (no failures allowed), but gets 80 instead!
const passThreshold = userConfig.passThreshold || 80;  // 0 || 80 = 80 ❌

// ✅ GOOD: User's 0 threshold is respected
const passThreshold = userConfig.passThreshold ?? 80;  // 0 ?? 80 = 0 ✅
```

### Use `type` Instead of `interface` (Unless Declaration Merging Needed)

**CRITICAL RULE**: Always use `type` unless you specifically need declaration merging.

```typescript
// ❌ BAD: Using interface when not needed
interface CheckmateConfig extends ProjectTestManagementIntegrationConfig {
  baseUrl: string;
  authToken: string;
}

interface CheckmateCreateRunRequest {
  projectId: number;
  runName: string;
}

// ✅ GOOD: Using type (no declaration merging needed)
type CheckmateConfig = ProjectTestManagementIntegrationConfig & {
  baseUrl: string;
  authToken: string;
};

type CheckmateCreateRunRequest = {
  projectId: number;
  runName: string;
};
```

**When to use `interface`:**
- Only when you need declaration merging (extending types across multiple declarations)
- Very rare in application code

**When to use `type`:**
- All other cases (99% of the time)
- Object shapes, unions, intersections, primitives

### Extract Types to `.interface.ts` Files

**CRITICAL RULE**: When a file has multiple type definitions, extract them to a separate `.interface.ts` file.

```typescript
// ❌ BAD: Types mixed with implementation
// checkmate.provider.ts
type CheckmateConfig = { ... };
type CheckmateCreateRunRequest = { ... };
type CheckmateCreateRunResponse = { ... };

export class CheckmateProvider {
  // ... implementation
}

// ✅ GOOD: Types in separate file
// checkmate.interface.ts
export type CheckmateConfig = { ... };
export type CheckmateCreateRunRequest = { ... };
export type CheckmateCreateRunResponse = { ... };

// checkmate.provider.ts
import type { CheckmateConfig, ... } from './checkmate.interface';

export class CheckmateProvider {
  // ... implementation
}
```

**File Structure:**
```
checkmate/
├── checkmate.constants.ts     # Constants (values)
├── checkmate.interface.ts     # Types (shapes)
├── checkmate.provider.ts      # Implementation (logic)
└── index.ts                   # Public exports
```

**CRITICAL: Enums Belong in `.interface.ts` Files**

```typescript
// ❌ BAD: Separate .enum.ts file
// platform.enum.ts
export enum TestPlatform { ... }

// ✅ GOOD: Enum in .interface.ts
// platform.interface.ts (GENERIC - used across domains)
export enum TestPlatform { ... }
export const TEST_PLATFORMS = Object.values(TestPlatform);

// ✅ GOOD: Utilities in separate .utils.ts file
// platform.utils.ts
import { TestPlatform, TEST_PLATFORMS } from './platform.interface';
export const isValidTestPlatform = (value: unknown): value is TestPlatform => { ... };

// ✅ GOOD: Domain-specific types use full name with dashes
// test-run.interface.ts (SPECIFIC to test management)
// test-management-config.interface.ts (SPECIFIC to test management)
```

**Naming Convention Rules:**
- **Generic concepts** (used across domains): `platform.interface.ts`, `status.interface.ts`
- **Domain-specific concepts**: `test-run.interface.ts`, `user-profile.interface.ts`
- `.interface.ts` = Types, Enums, Constants (type definitions)
- `.utils.ts` = Utility functions (runtime logic)
- `.enum.ts` is NOT a standard file type pattern

### Use ENUMs for Fixed Sets of Values

**CRITICAL RULE**: When you have a **stable, known set** of values (not user-configurable), use TypeScript ENUMs + Database ENUMs for type safety.

**When to use ENUM:**
- ✅ Fixed platform/target combinations (IOS, ANDROID_WEB, ANDROID_PLAYSTORE)
- ✅ Status values (PENDING, IN_PROGRESS, COMPLETED)
- ✅ Known categories that rarely change
- ✅ Values that need database-level validation

**When NOT to use ENUM:**
- ❌ User-configurable values
- ❌ Values that change frequently (weekly/daily)
- ❌ Different values per tenant/environment
- ❌ Values that need zero-downtime additions

```typescript
// ❌ BAD: Using generic string for fixed set
export type PlatformConfiguration = {
  platform: string;  // Any string allowed! Typos not caught!
  parameters: Record<string, unknown>;
};

// Response with generic string keys
export type CreateTestRunsResponse = {
  [platform: string]: {  // No type safety!
    runId: string;
  };
};

// ✅ GOOD: Using ENUM for fixed set
// Step 1: Create database enum
// migrations/007_xxx.sql
CREATE TYPE test_platform AS ENUM (
  'IOS',
  'ANDROID_WEB',
  'ANDROID_PLAYSTORE'
);

// Step 2: Create TypeScript enum in .interface.ts file
// types/platform.interface.ts (GENERIC concept, no domain prefix!)
export enum TestPlatform {
  IOS = 'IOS',
  ANDROID_WEB = 'ANDROID_WEB',
  ANDROID_PLAYSTORE = 'ANDROID_PLAYSTORE'
}

export const TEST_PLATFORMS = Object.values(TestPlatform);

// Step 3: Create utility functions in .utils.ts file
// types/platform.utils.ts (GENERIC concept, no domain prefix!)
import { TestPlatform, TEST_PLATFORMS } from './platform.interface';

export const isValidTestPlatform = (value: unknown): value is TestPlatform => {
  const isString = typeof value === 'string';
  if (!isString) {
    return false;
  }
  return TEST_PLATFORMS.includes(value as TestPlatform);
};

// Step 4: Use enum in types
export type PlatformConfiguration = {
  platform: TestPlatform;  // ✅ Type-safe! Typos caught at compile time!
  parameters: Record<string, unknown>;
};

// Type-safe response with enum keys
export type CreateTestRunsResponse = {
  [K in TestPlatform]?: {  // ✅ Type-safe keys!
    runId: string;
  };
};

// Step 4: Add database constraint for JSONB validation
ALTER TABLE configs
  ADD CONSTRAINT check_valid_platforms
  CHECK (
    (SELECT bool_and(
      (value->>'platform')::text IN ('IOS', 'ANDROID_WEB', 'ANDROID_PLAYSTORE')
    )
    FROM jsonb_array_elements(platform_configurations) AS value)
  );
```

**Benefits:**
1. ✅ **Compile-time safety** - TypeScript catches typos (`'ios'` vs `'IOS'`)
2. ✅ **Database validation** - Invalid values rejected at DB level
3. ✅ **IDE autocomplete** - See all valid options while typing
4. ✅ **Runtime validation** - Use type guards for safe narrowing
5. ✅ **Refactoring support** - Rename works across entire codebase
6. ✅ **Better error messages** - Show valid options in validation errors

**Adding New Enum Values:**
```sql
-- Step 1: Database migration
ALTER TYPE test_platform ADD VALUE 'TVOS';

-- Step 2: Update TypeScript enum
export enum TestPlatform {
  IOS = 'IOS',
  ANDROID_WEB = 'ANDROID_WEB',
  ANDROID_PLAYSTORE = 'ANDROID_PLAYSTORE',
  TVOS = 'TVOS'  // ← Add new value
}
```

**Everything else automatically works** - validation, type checking, autocomplete!

### Consolidate Duplicate Types

**CRITICAL RULE**: When multiple types have identical structure, consolidate them into a single type.

```typescript
// ❌ BAD: Duplicate types with same structure
type ResetTestRunRequest = {
  runId: string;
  releaseConfigId: string;
};

type CancelTestRunRequest = {
  runId: string;
  releaseConfigId: string;
};

// Different methods using duplicate types
async resetTestRun(request: ResetTestRunRequest): Promise<void> { ... }
async cancelTestRun(request: CancelTestRunRequest): Promise<void> { ... }

// ✅ GOOD: Single consolidated type
type TestRunActionRequest = {
  runId: string;
  releaseConfigId: string;
};

// Both methods use the same type
async resetTestRun(request: TestRunActionRequest): Promise<void> { ... }
async cancelTestRun(request: TestRunActionRequest): Promise<void> { ... }
```

**Why this matters:**
- DRY (Don't Repeat Yourself) - single source of truth
- Easier to maintain - change once, applies everywhere
- Clearer intent - shows these operations are structurally identical
- Reduces cognitive load - fewer type definitions to remember

**When to consolidate:**
- Types with identical structure
- Types used for similar operations (create/update, reset/cancel, etc.)
- Types that will likely evolve together

**When NOT to consolidate:**
- Types that happen to be identical now but have different semantic meaning
- Types that may diverge in the future based on business requirements

### Use `as const` for Constants
Always use `as const` assertion for readonly constants:

```typescript
// ✅ GOOD: Properly typed, immutable
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201
} as const;

// ❌ BAD: Mutable, loses literal type
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201
};
```

### Document Constants
Add JSDoc comments for complex constant sets:

```typescript
/**
 * Global HTTP status codes
 * Use these constants instead of hardcoded status codes
 */
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500
} as const;
```

## File Naming Conventions

### CRITICAL RULE: Use `[category].[type].ts` Format

**File Naming Pattern:** `[category].[type].ts`

Where:
- `[category]` = What domain/feature the file is about (http, auth, user, validation, etc.)
- `[type]` = What kind of file it is (constants, utils, service, interface, types, etc.)

### ❌ FORBIDDEN File Names

**Generic names with no context:**
- ❌ `common.ts` / `utils.ts` / `helpers.ts`
- ❌ `misc.ts` / `shared.ts` / `functions.ts`
- ❌ `constants.ts` (what constants?)

**Wrong separator (use dot, not dash/underscore):**
- ❌ `http-constants.ts` (use `http.constants.ts`)
- ❌ `error-utils.ts` (use `error.utils.ts`)
- ❌ `http_utils.ts` (use `http.utils.ts`)

**Wrong file type for enums:**
- ❌ `platform.enum.ts` (enums belong in `.interface.ts` files!)
- ❌ `status.enum.ts` (enums belong in `.interface.ts` files!)

**Wrong naming for generic vs. domain-specific:**
- ❌ `test-platform.interface.ts` (platform is GENERIC, use `platform.interface.ts`)
- ❌ `run.interface.ts` (too generic, use `test-run.interface.ts`)
- ✅ Use `platform.interface.ts` for GENERIC concepts (used across domains)
- ✅ Use `test-run.interface.ts` for DOMAIN-SPECIFIC concepts
- ✅ Use `platform.utils.ts` for utility functions (generic)
- ✅ Use `test-run.utils.ts` for utility functions (domain-specific)

**Redundant naming (already in specific folder):**
- ❌ `utils/error-utils.ts` (redundant "utils")
- ❌ `utils/validation-utils.ts` (redundant "utils")

### ✅ REQUIRED: `[category].[type].ts` Format

```typescript
// ❌ BAD: Generic or wrong format
common.ts              // No category
utils.ts              // No category
helpers.ts            // No category
constants.ts          // No category
http-constants.ts     // Wrong separator (dash instead of dot)
error-utils.ts        // Wrong separator (dash instead of dot)

// ✅ GOOD: [category].[type].ts format
http.constants.ts     // HTTP constants
http.utils.ts         // HTTP utilities
auth.service.ts       // Authentication service
user.interface.ts     // User interfaces/types
validation.utils.ts   // Validation utilities
date.utils.ts         // Date utilities
string.utils.ts       // String utilities

// ✅ GOOD: Inside specific folders, just [category].ts is fine
utils/error.ts        // Error utilities (already in utils folder)
utils/hash.ts         // Hash utilities (already in utils folder)
types/user.ts         // User types (already in types folder)
```

### File Organization Examples

#### Global Utilities (`api/script/utils/`)

```
api/script/utils/
  ├── http.constants.ts     ✅ HTTP status codes and constants
  ├── error.ts              ✅ Generic error handling utilities
  ├── hash.ts               ✅ Hashing functions (could be hash-utils.ts if outside utils/)
  ├── converter.ts          ✅ Data conversion utilities
  ├── validation.ts         ✅ Generic validation functions
  ├── security.ts           ✅ Security utilities
  └── tracer.ts             ✅ Tracing/logging utilities
```

#### Domain-Specific Utilities

```
api/script/utils/integrations/test-management/
  ├── api-response.utils.ts    ✅ Test management API response formatting
  ├── field-validation.utils.ts ✅ Test management field validation
  └── index.ts                 ✅ Exports
```

### Guidelines for Utility Files

1. **Use `[category].[type].ts` Format**:
   - Error handling? → `error.utils.ts` (or just `error.ts` if in utils/ folder)
   - HTTP operations? → `http.utils.ts`
   - String operations? → `string.utils.ts`
   - Constants? → `http.constants.ts`, `validation.constants.ts`

2. **Avoid Redundancy in Folder Structure**:
   - ❌ `utils/error-utils.ts` (redundant "utils")
   - ✅ `utils/error.ts` (already in utils folder)
   - ✅ `lib/http.utils.ts` (outside utils folder, so specify)

3. **Domain Prefix for Domain-Specific**: 
   - `test-management.utils.ts` (if truly specific)
   - Or place in domain folder: `integrations/test-management/api-response.utils.ts`

4. **Single Responsibility**: Each file should have ONE clear purpose
   - ❌ Don't mix: error handling + string formatting + date parsing
   - ✅ Do split: `error.ts` + `string.utils.ts` + `date.utils.ts`

5. **Check Existing Files First**: Before creating new utilities
   - `hash.ts` already exists in utils/? Use it!
   - `converter.ts` already exists? Use it!
   - Don't create duplicates with different names

### Refactoring Legacy "common.ts" Files

If you encounter generic files like `common.ts`:

1. **Audit the contents** - What's actually inside?
2. **Categorize functions** - Group by purpose
3. **Create specific files** - One per category
4. **Move functions** - Migrate to appropriate files
5. **Update imports** - Fix all references
6. **Delete generic file** - Remove the "junk drawer"

**Example Refactoring:**

```typescript
// ❌ BEFORE: common.ts (junk drawer)
export function getErrorMessage(...) { ... }      // Error handling
export function hashWithSHA256(...) { ... }       // Hashing
export function convertToSnakeCase(...) { ... }   // String conversion
export function streamToBuffer(...) { ... }       // Stream handling

// ✅ AFTER: Split into specific files with proper naming
// utils/error.ts (in utils folder, so no need for .utils suffix)
export function getErrorMessage(...) { ... }

// utils/hash.ts (in utils folder)
export function hashWithSHA256(...) { ... }

// utils/string.utils.ts or converter.ts
export function convertToSnakeCase(...) { ... }

// utils/stream.utils.ts
export function streamToBuffer(...) { ... }
```

### Folder and File Naming Consistency Across Layers

**CRITICAL RULE**: Maintain consistent naming across all layers (services, controllers, types, routes) for the same domain/feature.

```typescript
// ✅ GOOD: Consistent naming across all layers
services/integrations/test-management/
  ├── test-run.service.ts           // Service layer
  ├── project-integration.service.ts
  └── release-config.service.ts

controllers/integrations/test-management/
  ├── test-run/
  │   └── test-run.controller.ts     // Controller layer (matches service)
  ├── project-integration/
  │   └── project-integration.controller.ts
  └── release-config/
      └── release-config.controller.ts

types/integrations/test-management/
  ├── test-run/
  │   ├── test-run.interface.ts      // Types layer (matches service)
  │   └── index.ts
  ├── project-integration/
  │   ├── project-integration.interface.ts
  │   └── index.ts
  └── release-config/
      ├── release-config.interface.ts
      └── index.ts

routes/integrations/test-management/
  ├── test-run/
  │   └── test-run.routes.ts         // Routes layer (matches service)
  ├── project-integration/
  │   └── project-integration.routes.ts
  └── release-config/
      └── release-config.routes.ts

// ❌ BAD: Inconsistent naming across layers
services/integrations/test-management/
  ├── run.service.ts                 // ❌ Too generic
  └── integration.service.ts         // ❌ Too generic

controllers/integrations/test-management/
  ├── test-run-operations/           // ❌ Different name than service
  │   └── test-run-operations.controller.ts
  └── integration/                   // ❌ Different name than service
      └── integration.controller.ts

types/integrations/test-management/
  └── test-run-operations.interface.ts  // ❌ Not in subfolder, inconsistent name

routes/integrations/test-management/
  ├── release-test-run/              // ❌ Different name than service
  │   └── release-test-run.routes.ts
  └── config/                        // ❌ Too generic
      └── config.routes.ts
```

**Rules for Consistency:**
1. **Same base name across all layers** - If service is `test-run.service.ts`, controller should be `test-run.controller.ts`
2. **Same folder structure** - If types are in `test-run/test-run.interface.ts`, controller should be in `test-run/test-run.controller.ts`
3. **Avoid generic names** - Use specific domain names like `test-run`, not `run` or `operations`
4. **Subfolder for types** - Types should be in subfolders with `index.ts`, not flat files at the root
5. **Match service naming** - Service layer names should drive the naming for other layers

**Why this matters:**
- Easy to find related files across layers
- Clear mental model of the codebase structure
- Reduced cognitive load when navigating
- Consistent naming aids searchability
- Makes refactoring easier

**Quick test for consistency:**
If you're looking at `test-run.service.ts`, you should be able to guess:
- Controller: `test-run/test-run.controller.ts` ✅
- Types: `test-run/test-run.interface.ts` ✅
- Routes: `test-run/test-run.routes.ts` ✅

If you can't predict the names, the structure needs fixing!

## Controller/Factory Pattern

### CRITICAL RULE: No Huge Nested Functions

**DON'T** define large nested functions inside factory functions.

### ❌ BAD: Nested Functions Inside Factory

```typescript
export const createController = (service: Service) => {
  const handlerOne = async (req, res) => {
    // 50 lines of code...
  };
  
  const handlerTwo = async (req, res) => {
    // 50 lines of code...
  };
  
  return { handlerOne, handlerTwo };
};
```

**Problems:**
- Hard to read (deeply nested)
- Hard to test individual handlers
- Poor code organization
- Functions are hidden inside another function

### ✅ GOOD: Top-Level Handler Functions

```typescript
/**
 * Handler documentation
 */
const handlerOneHandler = (service: Service) =>
  async (req: Request, res: Response): Promise<void> => {
    // 50 lines of code...
  };

/**
 * Handler documentation
 */
const handlerTwoHandler = (service: Service) =>
  async (req: Request, res: Response): Promise<void> => {
    // 50 lines of code...
  };

export const createController = (service: Service) => ({
  handlerOne: handlerOneHandler(service),
  handlerTwo: handlerTwoHandler(service)
});
```

**Benefits:**
- Handlers are at top level (easy to find and read)
- Each handler is independently testable
- Clear separation of concerns
- Factory function is just composition
- Better for code navigation

### Pattern Rules

1. **Define handlers at top level** - Not nested inside factory
2. **Use currying for dependency injection** - `(service) => async (req, res) => {}`
3. **Factory is only for composition** - Just returns object with handlers
4. **Use descriptive names** - `createIntegrationHandler`, not just `create`
5. **Document each handler** - JSDoc comment above each function

## Pure Functions & Response Builders

### CRITICAL RULE: Use Pure Functions Where Applicable

**ALWAYS use existing pure functions** instead of manually building responses or repeating logic.

### ❌ BAD: Manual Response Building (Repetitive)

```typescript
// Controller 1
res.status(HTTP_STATUS.OK).json({
  success: RESPONSE_STATUS.SUCCESS,
  data: result
});

// Controller 2 - Same pattern repeated
res.status(HTTP_STATUS.OK).json({
  success: RESPONSE_STATUS.SUCCESS,
  data: integration
});

// Error handling - Repeated pattern
res.status(HTTP_STATUS.BAD_REQUEST).json({
  success: RESPONSE_STATUS.FAILURE,
  error: message
});
```

**Problems:**
- Code duplication
- Hard to test
- Inconsistent responses
- Easy to make mistakes
- Hard to maintain

### ✅ GOOD: Pure Response Builders (DRY)

```typescript
// Import pure response builders
import {
  successResponse,
  successMessageResponse,
  errorResponse,
  validationErrorResponse,
  notFoundResponse,
  getErrorStatusCode
} from '~utils/response.utils';

// Use pure functions
res.status(HTTP_STATUS.OK).json(successResponse(result));

res.status(HTTP_STATUS.CREATED).json(successResponse(integration));

res.status(HTTP_STATUS.OK).json(
  successMessageResponse('Integration deleted successfully')
);

const statusCode = getErrorStatusCode(error);
res.status(statusCode).json(
  errorResponse(error, 'Failed to create integration')
);

res.status(HTTP_STATUS.BAD_REQUEST).json(
  validationErrorResponse('field', 'Field is required')
);

res.status(HTTP_STATUS.NOT_FOUND).json(
  notFoundResponse('Integration')
);
```

**Benefits:**
- Single source of truth
- Highly testable (pure functions)
- Consistent response format
- Easy to maintain
- Type-safe
- Self-documenting

### Available Pure Response Builders

All available in `~utils/response.utils`:

```typescript
// Success responses
successResponse<T>(data: T, message?: string): SuccessResponse<T>
successMessageResponse(message: string): SuccessResponse<undefined>

// Error responses
errorResponse(error: unknown, context?: string): ErrorResponse
validationErrorResponse(field: string, message: string): ErrorResponse
configurationErrorResponse(message: string, details?: Record<string, unknown>): ErrorResponse
notFoundResponse(resource: string): ErrorResponse

// Helpers
getErrorStatusCode(error: unknown): number // Intelligent status code from error
verificationResultToResponse(result: {...}): SuccessResponse | ErrorResponse
```

### When to Extract Pure Functions

Extract logic into pure functions when you see:

1. **Repeated patterns** - Same logic in multiple places
2. **Complex validation** - Extract to `validate[Something]` functions
3. **Data transformations** - Extract to `map[Something]` or `transform[Something]`
4. **Business logic** - Extract to domain-specific pure functions
5. **Conditional logic** - Extract to `is[Something]` or `should[Something]` predicates

### Example: Validation Helper

```typescript
// ❌ BAD: Inline validation repeated everywhere
if (!runId || typeof runId !== 'string') {
  res.status(HTTP_STATUS.BAD_REQUEST).json({
    success: RESPONSE_STATUS.FAILURE,
    error: 'runId is required'
  });
  return;
}

// ✅ GOOD: Pure validation + pure response builder
const runIdMissing = !runId;
const runIdNotString = typeof runId !== 'string';
const runIdInvalid = runIdMissing || runIdNotString;

if (runIdInvalid) {
  res.status(HTTP_STATUS.BAD_REQUEST).json(
    validationErrorResponse('runId', 'runId is required')
  );
  return;
}
```

### Rules for Pure Functions

1. **No side effects** - Don't mutate inputs or external state
2. **Same input = same output** - Deterministic behavior
3. **Testable in isolation** - No dependencies on external state
4. **Name clearly** - Function name should describe what it returns
5. **Keep them small** - One clear responsibility
6. **Document complex ones** - JSDoc for non-obvious behavior

### Example: Pure Business Logic

```typescript
// ✅ GOOD: Pure threshold evaluation
const calculatePassPercentage = (passed: number, total: number): number => {
  const totalIsZero = total === 0;
  if (totalIsZero) return 0;
  
  return (passed / total) * 100;
};

const isPassingThreshold = (
  passPercentage: number, 
  threshold: number
): boolean => {
  return passPercentage >= threshold;
};

const isReadyForApproval = (
  status: TestRunStatus,
  isPassingThreshold: boolean
): boolean => {
  const statusIsCompleted = status === 'COMPLETED';
  return statusIsCompleted && isPassingThreshold;
};

// Use in controller
const passPercentage = calculatePassPercentage(result.passed, result.total);
const isPassing = isPassingThreshold(passPercentage, config.threshold);
const readyForApproval = isReadyForApproval(result.status, isPassing);
```

## Avoiding Over-Engineering

### CRITICAL RULE: Balance Abstraction with Simplicity

**Don't create abstractions for things that are already clear.** Over-engineering makes code harder to read and maintain.

### ❌ BAD: Over-Engineered Constants

```typescript
// ❌ BAD: Constants for obvious literal values
export const CHECKMATE_TEST_COUNTS = {
  ZERO: 0,           // Just use 0!
  ONE: 1,            // Just use 1!
  NEGATIVE_ONE: -1   // Just use -1!
} as const;

export const CHECKMATE_DEFAULTS = {
  EMPTY_BODY: '{}',    // Just use '{}'!
  EMPTY_STRING: '',    // Just use ''!
  NULL_VALUE: null     // Just use null!
} as const;

// Usage - unnecessarily verbose
const count = CHECKMATE_TEST_COUNTS.ZERO;  // ❌
body: CHECKMATE_DEFAULTS.EMPTY_BODY         // ❌

// ✅ GOOD: Use the values directly
const count = 0;      // ✅ Clear and direct
body: '{}'            // ✅ Clear and direct
```

### ❌ BAD: Over-Engineered Helper Functions

```typescript
// ❌ BAD: Wrapper for built-in methods
const numberToString = (value: number): string => {
  return value.toString();
};

// Usage
const runId = numberToString(response.runId);  // ❌ Unnecessary wrapper

// ✅ GOOD: Use built-in method directly
const runId = response.runId.toString();  // ✅ Clear and standard
```

### ❌ BAD: Over-Engineered Boolean Logic

```typescript
// ❌ BAD: Breaking down simple checks into too many variables
const untestedCountIsZero = checkmateData.untested === 0;
const inProgressCountIsZero = inProgressCount === 0;
const bothCountsAreZero = untestedCountIsZero && inProgressCountIsZero;
const allTestsCompleted = bothCountsAreZero;  // ❌ Redundant intermediate variable

if (allTestsCompleted) { ... }

// ✅ GOOD: Direct, readable check
const allTestsCompleted = checkmateData.untested === 0 && inProgressCount === 0;

if (allTestsCompleted) { ... }
```

### ✅ GOOD: When to Use Constants

Constants are valuable when they:
1. **Have meaningful domain context** - `MAX_RETRY_ATTEMPTS`, `DEFAULT_TIMEOUT_MS`
2. **Are used multiple times** - DRY principle applies
3. **May need to change** - Configuration values
4. **Clarify intent** - `HTTP_STATUS.NOT_FOUND` is clearer than `404`
5. **Are non-obvious** - `BCRYPT_SALT_ROUNDS` explains the purpose

```typescript
// ✅ GOOD: Meaningful constants
export const CHECKMATE_DEFAULTS = {
  RUN_NAME: 'Test Run',           // ✅ Has domain meaning
  TIMEOUT_MS: 30000,               // ✅ Clarifies the unit
  MAX_RETRY_ATTEMPTS: 3            // ✅ May need tuning
} as const;

export const CHECKMATE_HTTP_STATUS = {
  OK: 200,                         // ✅ Standard, used everywhere
  UNAUTHORIZED: 401,               // ✅ More readable than 401
  NOT_FOUND: 404                   // ✅ Self-documenting
} as const;
```

### Quick Decision Guide

**Before creating a constant or helper, ask:**

1. ❓ "Does this add clarity or just verbosity?"
   - `COUNTS.ZERO` vs `0` → Just use `0`
   - `HTTP_STATUS.NOT_FOUND` vs `404` → Use constant

2. ❓ "Is this wrapping a standard language feature?"
   - `numberToString(x)` vs `x.toString()` → Use built-in
   - `safeJsonParse(str)` (with try-catch) → Helper adds value

3. ❓ "Am I creating intermediate variables that don't clarify?"
   - `const x = a; const y = b; const z = x && y; return z;` → Too much
   - `const isValid = hasName && hasEmail;` → Good abstraction

4. ❓ "Will this be used in multiple places?"
   - Used once → Inline it
   - Used 2+ times → Extract it

**Remember:** The goal is readable, maintainable code. Sometimes that means fewer abstractions, not more.

## Clean Code Principles (Summary)

1. **NO MAGIC STRINGS** - ALWAYS use constants from `constants.ts` files
2. **NO MAGIC NUMBERS** - Extract all numeric values to named constants (but don't over-engineer obvious values like `0`, `1`)
3. **Use pure functions** - Reuse existing pure functions instead of duplicating logic
4. **Proper constant placement** - Global vs domain-specific
5. **Use existing constants** - Check before creating new ones
6. **Meaningful names** - Self-documenting code (files AND variables)
7. **Specific file names** - No "common.ts", "utils.ts", or "helpers.ts"
8. **Enums in `.interface.ts` files** - NOT `.enum.ts`, utilities in `.utils.ts`
9. **Consistent naming across layers** - Same base name for service, controller, types, routes
10. **Type safety** - Use `as const` for readonly constants
11. **Module aliases** - Use `~utils`, `~types`, etc.
12. **Single responsibility** - Each file should have ONE clear purpose
13. **No huge nested functions** - Define at top level, factory only composes
14. **NEVER use `as` or `!`** - Use proper type guards and validation
15. **ALWAYS use `??` instead of `||`** - For default values (avoids falsy value bugs)
16. **Consolidate duplicate types** - Don't repeat identical type definitions
17. **Avoid over-engineering** - Don't abstract what's already clear

## Copyright Headers

**IMPORTANT**: Only add copyright headers to files from the original cloned codebase.

### Rules:
- ❌ **DO NOT** add Microsoft copyright to NEW files you create
- ✅ Keep existing copyright headers in files cloned from Microsoft's codebase
- ✅ New files should start directly with code/comments (no copyright header)

```typescript
// ❌ BAD: Adding copyright to NEW files
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

export const NEW_CONSTANT = { ... };

// ✅ GOOD: New files without copyright
export const NEW_CONSTANT = { ... };
```

## Before Committing

- [ ] **NO MAGIC STRINGS** - All error/success messages use constants from `constants.ts`
- [ ] **NO MAGIC NUMBERS** - All numeric values extracted to named constants (except obvious values like `0`, `1`)
- [ ] **NO HARDCODED HTTP STATUS CODES** - Use `HTTP_STATUS` from `~constants/http` everywhere (controllers, utilities, services)
- [ ] **Use pure functions** - All response building uses pure functions from `response.utils.ts`
- [ ] **NEVER use `as` or `!`** - All type assertions replaced with proper type guards
- [ ] **ALWAYS use `??` instead of `||`** - For default values (check all `||` usages)
- [ ] Constants are in the correct scope (global/domain/provider)
- [ ] **Constant names include domain/feature prefix** (e.g., `TEST_MANAGEMENT_ERROR_MESSAGES`)
- [ ] **Message strings include domain context** (e.g., "Test management integration not found")
- [ ] **File names follow `[category].[type].ts` convention** (e.g., `http.constants.ts`, `auth.service.ts`)
- [ ] **No generic file names** (no `common.ts`, `utils.ts`, `helpers.ts`, `constants.ts`)
- [ ] **Use dot separator, not dash** (`http.constants.ts`, not `http-constants.ts`, not `test-platform.interface.ts`)
- [ ] **Enums go in `.interface.ts` files, NOT `.enum.ts`** - Utilities go in `.utils.ts` files
- [ ] **Consistent naming across layers** - service/controller/types/routes use same base name
- [ ] **Types in subfolders with `index.ts`** - Not flat files (e.g., `test-run/test-run.interface.ts`)
- [ ] **Consolidate duplicate types** - No identical type definitions
- [ ] **Avoid redundancy in folder structure** (`utils/error.ts`, not `utils/error-utils.ts`)
- [ ] **No copyright headers on NEW files** (only keep on original cloned files)
- [ ] **Handlers defined at top level, not nested** (factory only composes)
- [ ] **Factory functions are simple composition** (no business logic inside)
- [ ] **No over-engineering** - Don't abstract obvious values or wrap built-in methods
- [ ] Imports use proper module aliases (`~utils`, `~types`, etc.)
- [ ] TypeScript types are correct (`as const`, use `type` not `interface`)
- [ ] **Use ENUM for fixed sets of values** - Platform/target combinations, statuses, categories (DB enum + TS enum + validation)
- [ ] Constants are documented if complex
- [ ] No duplicate constants across different scopes
- [ ] Each file has a single, clear purpose
- [ ] Linter passes without errors
- [ ] Build passes without errors (`npm run build`)


## ESLint Configuration

### CRITICAL RULE: Use TypeScript-Aware ESLint Rules

**NEVER disable lint rules to fix false positives. Fix the configuration instead.**

### ✅ CORRECT ESLint Configuration for TypeScript

```json
{
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "rules": {
    "no-unused-vars": "off",
    "@typescript-eslint/no-unused-vars": ["error", {
      "argsIgnorePattern": "^_",
      "varsIgnorePattern": "^_",
      "ignoreRestSiblings": true
    }]
  }
}
```

**Why:**
- ✅ Understands TypeScript constructor property shorthand
- ✅ Recognizes interface method parameters are documentation-only
- ✅ Allows underscore prefix for intentionally unused variables
- ✅ Maintains full lint protection
- ✅ Industry best practice

### ❌ WRONG: Disabling Lint Rules

```typescript
// ❌ BAD: Don't do this
export class Repository {
  constructor(
    // eslint-disable-next-line no-unused-vars
    private readonly model: ModelType
  ) {}
}
```

### ✅ RIGHT: Proper Configuration

```typescript
// ✅ GOOD: No comments needed with correct config
export class Repository {
  constructor(
    private readonly model: ModelType
  ) {}
}
```

**If you see "unused vars" errors for:**
- Constructor properties (`private readonly`)
- Interface method parameters
- Class properties

**→ Fix the ESLint config, don't disable the rule!**

## Strict Typing Rules

### CRITICAL RULE: NO `any` OR `as unknown`

**Never use `any` or `as unknown` except in rare, well-documented cases.**

#### ❌ FORBIDDEN

```typescript
function processData(data: any) { ... }
const result = response as unknown as User;
```

#### ✅ REQUIRED

```typescript
function processData(data: UserData) { ... }
const result = response as User;
```

### Type vs Value Pattern for Enums

```typescript
// ✅ GOOD: Provides both type AND value
export const TestRunStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED'
} as const;

export type TestRunStatus = typeof TestRunStatus[keyof typeof TestRunStatus];
```

## Post-Change Error Fixing

### CRITICAL RULE: Always Run Build

**After ANY changes:**
1. Run `npm run build`
2. Fix ALL errors
3. Run `npm run lint`
4. Fix ALL warnings

**Never** commit with compilation errors!


## Utility File Organization

### CRITICAL RULE: Generic vs Feature-Specific Utils

**Generic utilities** (used across multiple features):
- ✅ Place in `utils/` at root level
- ✅ Use `[category].[type].ts` naming (e.g., `response.utils.ts`, `http.constants.ts`)
- ❌ DO NOT place in feature-specific folders (e.g., `utils/integrations/test-management/`)

**Feature-specific utilities** (only used within one feature):
- ✅ Place in feature's utils folder (e.g., `utils/integrations/test-management/`)
- ✅ Must be genuinely feature-specific, not reusable elsewhere

### Examples

```typescript
// ❌ BAD: Generic response utilities in feature folder
utils/integrations/test-management/api-response.utils.ts
  - successResponse()      // Generic!
  - errorResponse()        // Generic!
  - validationError()      // Generic!

// ✅ GOOD: Generic utilities in root utils
utils/response.utils.ts
  - successResponse()      // Used by all APIs
  - errorResponse()        // Used by all APIs
  - validationError()      // Used by all APIs

// ✅ GOOD: Feature-specific utilities in feature folder
utils/integrations/test-management/test-run-mapper.utils.ts
  - mapCheckmateStatusToTestRunStatus()  // Only for test management
  - calculateTestPassPercentage()        // Only for test management
```

### Quick Check

Before creating a utility file, ask:
1. "Will this be used by other features?" → Root `utils/`
2. "Is this only for this feature?" → Feature-specific `utils/`
3. "Does this already exist somewhere?" → Search first!


## File Organization: Constants vs Utils

### CRITICAL DISTINCTION

**Constants** (immutable values):
- ✅ Place in `constants/` folder
- ✅ Use `[category].ts` naming (folder already indicates they're constants)
- ✅ Export using `as const` for type safety
- Examples: `http.ts`, `validation.ts`, `app.ts`

**Utils** (utility functions):
- ✅ Place in `utils/` folder
- ✅ Use `[category].utils.ts` naming
- ✅ Export functions, not constants
- Examples: `error.utils.ts`, `date.utils.ts`, `string.utils.ts`

### Structure

```
api/script/
├── constants/          # Global constants (immutable values)
│   ├── http.ts        # HTTP status codes, response statuses
│   ├── validation.ts  # Validation rules, limits
│   └── app.ts         # Application-wide constants
│
└── utils/             # Global utilities (functions)
    ├── error.utils.ts # Error handling functions
    ├── date.utils.ts  # Date manipulation functions
    └── response.utils.ts # API response builders
```

### Examples

```typescript
// ✅ GOOD: Constants in constants/
// constants/http.ts
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400
} as const;

// ✅ GOOD: Utilities in utils/
// utils/error.utils.ts
export function getErrorMessage(error: unknown): string {
  return error instanceof Error ? error.message : 'Unknown error';
}

// ❌ BAD: Mixing in same file
// utils/error.ts  (wrong - no .utils suffix)
export const ERROR_CODES = { ... };  // This is a constant!
export function getError() { ... }   // This is a utility!
```

### TypeScript Path Aliases

```json
{
  "paths": {
    "~constants/*": ["constants/*"],  // For constants
    "~utils/*": ["utils/*"]           // For utilities
  }
}
```

### Import Examples

```typescript
// Import constants
import { HTTP_STATUS } from '~constants/http';
import { MAX_FILE_SIZE } from '~constants/validation';

// Import utilities
import { getErrorMessage } from '~utils/error.utils';
import { formatDate } from '~utils/date.utils';
import { successResponse } from '~utils/response.utils';
```


## CRITICAL RULE: NO Feature Folders in Global Utils

### ❌ FORBIDDEN: Feature-Specific Subfolders in utils/

**NEVER create feature-specific subfolders in `utils/` or `constants/`**

```
❌ BAD - Feature folders in global utils:
utils/
├── integrations/          # ❌ NO! Feature name in utils
│   └── test-management/   # ❌ NO! Nested feature folders
├── releases/              # ❌ NO! Feature name in utils
└── projects/              # ❌ NO! Feature name in utils

constants/
├── integrations/          # ❌ NO! Feature name in constants
└── releases/              # ❌ NO! Feature name in constants
```

### ✅ CORRECT Structure

**Global utils/constants** = Generic, reusable across ALL features
**Feature-specific utils/constants** = Inside the feature's own folder

```
✅ GOOD - Clean separation:

# Global utilities (used by multiple features)
utils/
├── error.utils.ts         # ✅ Generic error handling
├── response.utils.ts      # ✅ Generic API responses
├── date.utils.ts          # ✅ Generic date formatting
└── string.utils.ts        # ✅ Generic string manipulation

constants/
├── http.ts                # ✅ Generic HTTP status codes
├── validation.ts          # ✅ Generic validation rules
└── app.ts                 # ✅ Generic app config

# Feature-specific utilities (only used within one feature)
controllers/integrations/test-management/
├── constants.ts           # ✅ Test-management specific constants
├── helpers.ts             # ✅ Test-management specific helpers
└── mappers.ts             # ✅ Test-management specific mappers

services/release-management/
├── constants.ts           # ✅ Release-management specific constants
└── utils.ts               # ✅ Release-management specific utils
```

### Decision Tree: Where Does This File Go?

```
Is the utility/constant used by multiple features?
│
├─ YES → Place in global utils/ or constants/
│         Use generic naming: error.utils.ts, http.ts
│
└─ NO  → Place in the feature's own folder
          Use feature context: test-management/constants.ts
```

### Examples of Past Mistakes (Learn From These!)

```typescript
// ❌ MISTAKE: Created utils/integrations/test-management/api-response.utils.ts
// ✅ FIX: Moved to utils/response.utils.ts (it's generic!)

// ❌ MISTAKE: Created utils/integrations/test-management/field-validation.utils.ts
// ✅ FIX: Deleted (was feature-specific, belonged in middleware or removed)

// ❌ MISTAKE: Had constants in utils/http.constants.ts
// ✅ FIX: Moved to constants/http.ts (cleaner separation)
```

### Quick Checklist Before Creating Files

**Before creating a file in `utils/` or `constants/`, ask:**

1. ❓ "Is this used by 2+ different features?" 
   - NO → Put it in the feature folder
   - YES → Continue to step 2

2. ❓ "Does this contain feature-specific domain logic?"
   - YES → Put it in the feature folder
   - NO → Continue to step 3

3. ❓ "Could this be useful in other projects?"
   - NO → Reconsider if it's truly generic
   - YES → OK to put in global utils/constants

**If in doubt: Keep it in the feature folder. It's easier to promote to global later than to clean up misplaced files!**

